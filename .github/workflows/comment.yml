name: PR Comment Bot

on:
  # This specifies that the workflow should trigger on pull_request events.
  pull_request:
    # We only want to run this when a pull request is first opened.
    # types: [opened]

    # For testing purpose, check it once the PR is opened.
    branches:
      - main
    
  workflow_dispatch:

jobs:
  Comment-on-PR:
    runs-on: ubuntu-latest

    # This gives the action the necessary permissions to write a comment on the pull request.
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Add comment to PR
        uses: actions/github-script@v7
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');

            // Get the pull request number from the event context
            const issue_number = context.issue.number;

            // Create a patch file containing only changes under /test and /tests directories
            try {
              execSync(`git diff ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} -- test/ tests/ > changes.patch`);
            } catch (error) {
              console.log('Error creating git diff:', error.message);
              // Try alternative method
              try {
                execSync(`git diff HEAD~1 HEAD -- test/ tests/ > changes.patch`);
                console.log('Used HEAD~1 HEAD as fallback for git diff');
              } catch (fallbackError) {
                console.log('Fallback git diff also failed:', fallbackError.message);
                return;
              }
            }
            
            // Read the patch file content
            let patchContent = '';
            try {
              patchContent = fs.readFileSync('changes.patch', 'utf8');
              console.log('Patch content:', patchContent);
            } catch (error) {
              console.log('Error reading patch file:', error);
              patchContent = 'No changes detected or error reading patch file.';
            }

            // Check if the patch file is empty
            if (!patchContent || patchContent.trim() === '') {
              console.log("No content changes detected.");
              return;
            }

            const apiUrl = 'https://4djfomzutg.execute-api.us-west-2.amazonaws.com/v1/api';            
            
            const headers = {
              'Content-Type': 'application/json',
              'x-api-key': 'ojR4WdbesL8l3pXNhsBlVau1FwBq5u9i1WL1nA16' 
            };

            // Read the prompt template from file
            let promptTemplate = '';
            try {
              promptTemplate = fs.readFileSync('.github/workflows/prompt.txt', 'utf8');
              console.log('Prompt template loaded successfully');
            } catch (error) {
              console.log('Error reading prompt file:', error);
              // Fallback to default prompt if file doesn't exist
              promptTemplate = 'Analyze and summarize the following code changes in this pull request, and response in GitHub Flavored Markdown format:\n\n${patchContent}';
            }

            // Replace the placeholder with actual patch content
            const finalPrompt = promptTemplate.replace('${patchContent}', patchContent);

            const body = {
              "user_id": "ftsai", 
              "prompts": [finalPrompt],
              "model": "ollama.deepseek-r1:latest"
            }

            console.log(`Calling API: ${apiUrl}`);
            
            const response = await fetch(apiUrl, {
              method: 'POST',
              headers: headers,
              body: JSON.stringify(body)
            });
            
            console.log(`HTTP Response Code: ${response.status} ${response.statusText}`);
            
            // Check if the response is successful
            if (!response.ok) {
              console.log(`API call failed with status: ${response.status} ${response.statusText}`);
              const errorText = await response.text();
              console.log(`Error response body: ${errorText}`);
              return;
            }
            
            const data = await response.json();
            console.log(`data received:`, data);
            
            // Use the response directly since it's already in markdown format
            let markdownResponse = data.response;

            // Ensure newlines are properly formatted
            markdownResponse = markdownResponse.replace(/\\n/g, '\n'); 
            console.log(`Markdown response:`, markdownResponse);

            // Format the comment with the markdown response
            const formattedComment = 
            `
            ${markdownResponse}

            *This comment was automatically generated by NSChat to help evaluate changes in this pull request.*

            <details>
            <summary>ðŸ“Š Analysis Details</summary>

            - **Model Used**: ${body.model}
            - **Generated**: ${new Date().toISOString()}
            - **Prompt**: Analyze and summarize the following code changes in this pull request

            </details>`;

            // Post a comment on the pull request
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue_number,
              body: formattedComment
            });
