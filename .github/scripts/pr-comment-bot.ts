// .github/scripts/pr-comment-bot.ts
import * as core from '@actions/core';
import * as github from '@actions/github';
import * as fs from 'fs';
import { execSync } from 'child_process';

/**
 * The main function for the action.
 */
async function run(): Promise<void> {
  try {
    // --- 1. Get Inputs and Context ---
    const token = process.env.GITHUB_TOKEN;
    const apiKey = process.env.API_KEY;
    const context = github.context;
    const prNumber = context.payload.pull_request?.number;

    if (!token) {
      core.setFailed('GITHUB_TOKEN is not set. Please add it to the env section of the workflow.');
      return;
    }
    if (!prNumber) {
      core.setFailed('Could not get pull request number from context.');
      return;
    }

    const baseSha = process.env.BASE_SHA || context.payload.pull_request?.base?.sha;
    const headSha = process.env.HEAD_SHA || context.payload.pull_request?.head?.sha;

    // --- 2. Create Git Diff Patch ---
    try {
      core.info(`Creating diff between ${baseSha} and ${headSha}`);
      execSync(`git diff ${baseSha} ${headSha} -- test/ tests/ > changes.patch`);
    } catch (error) {
      core.warning(`Standard git diff failed: ${(error as Error).message}. Trying fallback.`);
      try {
        execSync(`git diff HEAD~1 HEAD -- test/ tests/ > changes.patch`);
        core.info('Used HEAD~1 HEAD as fallback for git diff');
      } catch (fallbackError) {
        core.setFailed(`Fallback git diff also failed: ${(fallbackError as Error).message}`);
        return;
      }
    }

    const patchContent = fs.readFileSync('changes.patch', 'utf8');
    if (!patchContent || patchContent.trim() === '') {
      core.info("No content changes detected in 'test/' or 'tests/' directories. Exiting.");
      return;
    }

    // --- 3. Call External API with Patch Content ---
    const apiUrl = 'https://4djfomzutg.execute-api.us-west-2.amazonaws.com/v1/api';
    const headers = {
      'Content-Type': 'application/json',
      'x-api-key': apiKey || ''
    };

    let promptTemplate: string;
    try {
      promptTemplate = fs.readFileSync('.github/workflows/prompt.txt', 'utf8');
      core.info('Prompt template loaded successfully from file.');
    } catch (error) {
      core.warning('Could not read prompt.txt, using default prompt.');
      promptTemplate = 'Analyze and summarize the following code changes in this pull request, and response in GitHub Flavored Markdown format:\n\n${patchContent}';
    }

    const finalPrompt = promptTemplate.replace('${patchContent}', patchContent);
    const requestBody = {
      "user_id": "ftsai",
      "prompts": [finalPrompt],
      "model": "ollama.deepseek-r1:latest"
    };

    core.info(`Calling API: ${apiUrl}`);
    let response: Response | null = null;
    const retryDelays = [5, 10, 20, 60]; // seconds

    for (let attempt = 0; attempt <= retryDelays.length; attempt++) {
        if (attempt > 0) {
            const delay = retryDelays[attempt - 1];
            core.info(`API call failed. Retrying in ${delay} seconds... (Attempt ${attempt})`);
            await new Promise(resolve => setTimeout(resolve, delay * 1000));
        }
        
        response = await fetch(apiUrl, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(requestBody)
        });

        core.info(`HTTP Response Code: ${response.status} ${response.statusText}`);

        if (response.ok) {
            break; // Success, exit loop
        }
        if (response.status !== 429) {
            // Don't retry on non-429 errors
            const errorText = await response.text();
            core.setFailed(`API call failed with status ${response.status}: ${errorText}`);
            return;
        }
    }
    
    if (!response || !response.ok) {
        core.setFailed(`API call failed after all retries. Last status: ${response?.status}`);
        return;
    }
    
    const data = await response.json();
    let markdownResponse = data.response.replace(/\\n/g, '\n');

    // --- 4. Format and Post Comment ---
    const formattedComment = `
${markdownResponse}

*This comment was automatically generated by NSChat to help evaluate changes in this pull request.*

<details>
<summary>ðŸ“Š Analysis Details</summary>

- **Model Used**: \`${requestBody.model}\`
- **Generated**: \`${new Date().toISOString()}\`

</details>`;

    const octokit = github.getOctokit(token);
    await octokit.rest.issues.createComment({
      owner: context.repo.owner,
      repo: context.repo.repo,
      issue_number: prNumber,
      body: formattedComment
    });

    core.info(`Successfully posted a comment to PR #${prNumber}.`);

  } catch (error) {
    if (error instanceof Error) {
      core.setFailed(error.message);
    } else {
      core.setFailed('An unknown error occurred');
    }
  }
}

run();
